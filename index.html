<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noindex">
    <title>LDO/USDT 15m - Nadaraya-Watson Envelope</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
        body { background-color: #000000; color: white; font-family: Arial, sans-serif; margin: 0; padding: 20px; }
        canvas { max-width: 100%; }
        #infoBar { text-align: center; font-size: 16px; margin: 10px 0; }
        #tradeLog, #aiSection { 
            max-height: 150px; 
            overflow-y: auto; 
            font-size: 14px; 
            margin-top: 10px; 
            padding: 10px; 
            background-color: #1a1a1a; 
            border: 1px solid #333; 
        }
        #aiSection { max-height: 300px; }
        h2 { font-size: 18px; margin: 10px 0 5px; }
    </style>
</head>
<body>
    <canvas id="priceChart"></canvas>
    <div id="infoBar">
        <span id="currentPrice">Текущая цена: N/A</span> | 
        <span id="stats">Открыто: 0 | Сделок: 0 | Прибыль: 0 USDT</span> | 
        <label><input type="checkbox" id="muteSound" checked> Звук</label>
    </div>
    <div id="tradeLog"><h2>Сделки</h2></div>
    <div id="aiSection"><h2>ИИ</h2><div id="aiAnalysis"></div><h2>Рекомендации</h2><div id="aiRecommendations"></div></div>

    <script>
        const h = 8;
        const mult = 2.89;
        const mult2 = 1.7;
        const maxCandles = 126;
        const maxCalcCandles = 500;
        const tradeSize = 100;
        const commissionRate = 0.0004;

        const openSound = new Audio('https://www.soundjay.com/buttons/beep-01a.mp3');
        const closeSound = new Audio('https://www.soundjay.com/buttons/beep-07a.mp3');

        const ctx = document.getElementById('priceChart').getContext('2d');
        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [
                    { label: 'Upper Wick', data: [], borderColor: '#ff9800', borderWidth: 1, pointRadius: 0, fill: false },
                    { label: 'Lower Wick', data: [], borderColor: '#90bff9', borderWidth: 1, pointRadius: 0, fill: false },
                    { label: 'Upper Envelope Wide', data: [], borderColor: '#4caf50', borderWidth: 1, pointRadius: 0, fill: false },
                    { label: 'Lower Envelope Wide', data: [], borderColor: '#4caf50', borderWidth: 1, pointRadius: 0, fill: false },
                    { label: 'Middle Envelope', data: [], borderColor: '#808080', borderWidth: 1, pointRadius: 0, fill: false },
                    { label: 'Upper Envelope Narrow', data: [], borderColor: '#ffeb3b', borderWidth: 1, pointRadius: 0, fill: false },
                    { label: 'Lower Envelope Narrow', data: [], borderColor: '#ffeb3b', borderWidth: 1, pointRadius: 0, fill: false },
                    { label: 'EMA 100', data: [], borderColor: '#d873f6', borderWidth: 2, pointRadius: 0, fill: false },
                    { label: 'EMA 200', data: [], borderColor: '#ffffff', borderWidth: 2, pointRadius: 0, fill: false },
                    { label: 'Last Price', data: [], borderColor: '#ffffff', borderWidth: 1, pointRadius: 0, fill: false, borderDash: [5, 5] },
                    { label: 'Trade Lines', data: [], borderColor: '#4caf50', borderWidth: 2, pointRadius: 0, fill: false, borderDash: [2, 2] }
                ]
            },
            options: {
                responsive: true,
                plugins: { legend: { display: false }, annotation: { annotations: [] } },
                scales: {
                    x: { 
                        type: 'time', 
                        time: { unit: 'minute', displayFormats: { minute: 'HH:mm' } }, 
                        title: { display: true, text: 'Time' }, 
                        ticks: { source: 'auto' }, 
                        bounds: 'data', 
                        offset: true, 
                        grid: { color: '#333333' } 
                    },
                    y: { 
                        title: { display: true, text: 'Price (USDT)' }, 
                        position: 'right', 
                        grid: { color: '#333333' }, 
                        ticks: { 
                            color: '#ffffff', 
                            callback: function(value) { return value.toFixed(4); }, 
                            padding: 50 
                        } 
                    }
                },
                layout: { padding: { right: 0 } },
                backgroundColor: '#000000'
            }
        });

        function gauss(x, h) {
            return Math.exp(-(Math.pow(x, 2) / (h * h * 2)));
        }

        function calculateNWE(prices, multiplier) {
            const nwe = [];
            let sae = 0;
            const n = prices.length;
            for (let i = 0; i < n; i++) {
                let sum = 0, sumw = 0;
                for (let j = 0; j < n; j++) {
                    const w = gauss(i - j, h);
                    sum += prices[j] * w;
                    sumw += w;
                }
                const y = sum / sumw;
                sae += Math.abs(prices[i] - y);
                nwe.push(y);
            }
            sae = (sae / Math.min(499, n - 1)) * multiplier;
            return { nwe, sae };
        }

        function calculateEMA(prices, period) {
            const k = 2 / (period + 1);
            const ema = [];
            let sum = 0;
            for (let i = 0; i < Math.min(period, prices.length); i++) { sum += prices[i]; }
            let initialEMA = sum / Math.min(period, prices.length);
            ema.push(initialEMA);
            for (let i = Math.min(period, prices.length); i < prices.length; i++) {
                const value = prices[i] * k + ema[ema.length - 1] * (1 - k);
                ema.push(value);
            }
            for (let i = 0; i < Math.min(period, prices.length) - 1; i++) { ema.unshift(initialEMA); }
            return ema;
        }

        const candles = [];
        const closePrices = [];
        let lastPrice = null;
        let lastPriceTime = null;
        let activeTrade = null;
        const tradeHistory = [];
        const tradeAnnotations = [];
        let aiEntryPoint = null;
        let aiExitPoint = null;

        class TradingAI {
            checkTradeConditions(price, time, lowerWide, upperWide, lowerNarrow, upperNarrow) {
                if (!activeTrade && aiEntryPoint && aiExitPoint) {
                    if (aiEntryPoint.type === 'long' && price <= aiEntryPoint.price) {
                        this.openTrade('long', price, time, aiExitPoint.price);
                    } else if (aiEntryPoint.type === 'short' && price >= aiEntryPoint.price) {
                        this.openTrade('short', price, time, aiExitPoint.price);
                    }
                } else if (activeTrade) {
                    this.updateTakeProfit(time, lowerNarrow, upperNarrow);
                    this.checkCloseTrade(price);
                    this.updateTradeInfo();
                }
            }

            openTrade(type, price, time, takeProfit) {
                activeTrade = {
                    type,
                    openPrice: price,
                    openTime: time,
                    takeProfit,
                    size: tradeSize,
                    startTime: Date.now()
                };
                const tradeColor = type === 'long' ? '#00ff00' : '#ff0000';
                const minTime = candles.length > 0 ? candles[0].x.getTime() : time.getTime() - 15*60*1000;
                const maxTime = candles.length > 0 ? candles[candles.length - 1].x.getTime() + 15*60*1000 : time.getTime() + 15*60*1000;
                tradeAnnotations.push({
                    type: 'line',
                    xMin: minTime,
                    xMax: maxTime,
                    yMin: price,
                    yMax: price,
                    borderColor: '#f23645',
                    borderWidth: 1,
                    id: 'openLine'
                });
                tradeAnnotations.push({
                    type: 'line',
                    xMin: minTime,
                    xMax: maxTime,
                    yMin: takeProfit,
                    yMax: takeProfit,
                    borderColor: '#00c108',
                    borderWidth: 1,
                    id: 'tpLine'
                });
                this.updateTradeInfo();
                updateStats();
                updateTradeLog();
                if (document.getElementById('muteSound').checked) openSound.play();
            }

            updateTakeProfit(time, lowerNarrow, upperNarrow) {
                const tp = activeTrade.type === 'long' ? aiExitPoint.price : aiExitPoint.price;
                activeTrade.takeProfit = tp;
                const tpAnnotation = tradeAnnotations.find(a => a.id === 'tpLine');
                const minTime = candles.length > 0 ? candles[0].x.getTime() : time.getTime() - 15*60*1000;
                const maxTime = candles.length > 0 ? candles[candles.length - 1].x.getTime() + 15*60*1000 : time.getTime() + 15*60*1000;
                if (tpAnnotation) {
                    tpAnnotation.xMin = minTime;
                    tpAnnotation.xMax = maxTime;
                    tpAnnotation.yMin = tp;
                    tpAnnotation.yMax = tp;
                }
            }

            checkCloseTrade(price) {
                if (activeTrade.type === 'long' && price >= activeTrade.takeProfit) {
                    this.closeTrade(price);
                } else if (activeTrade.type === 'short' && price <= activeTrade.takeProfit) {
                    this.closeTrade(price);
                }
            }

            closeTrade(price) {
                const positionSize = tradeSize / activeTrade.openPrice;
                const rawProfit = activeTrade.type === 'long' 
                    ? (price - activeTrade.openPrice) * positionSize
                    : (activeTrade.openPrice - price) * positionSize;
                const commission = (tradeSize + (tradeSize + rawProfit)) * commissionRate;
                const profit = rawProfit - commission;
                
                tradeHistory.push({
                    type: activeTrade.type,
                    openPrice: activeTrade.openPrice,
                    closePrice: price,
                    openTime: activeTrade.openTime,
                    closeTime: lastPriceTime,
                    profit
                });

                const closeTime = lastPriceTime;
                const tradeColor = activeTrade.type === 'long' ? '#00ff00' : '#ff0000';
                tradeAnnotations.push({
                    type: 'point',
                    xValue: activeTrade.openTime,
                    yValue: activeTrade.openPrice,
                    backgroundColor: tradeColor,
                    borderColor: tradeColor,
                    radius: 4
                });
                tradeAnnotations.push({
                    type: 'point',
                    xValue: closeTime,
                    yValue: price,
                    backgroundColor: tradeColor,
                    borderColor: tradeColor,
                    radius: 4
                });

                chart.data.datasets[10].data.push(
                    { x: activeTrade.openTime, y: activeTrade.openPrice },
                    { x: closeTime, y: price },
                    { x: null, y: null }
                );

                tradeAnnotations.splice(tradeAnnotations.findIndex(a => a.id === 'openLine'), 1);
                tradeAnnotations.splice(tradeAnnotations.findIndex(a => a.id === 'tpLine'), 1);

                activeTrade = null;
                document.getElementById('tradeInfo').textContent = '';
                updateStats();
                updateTradeLog();
                aiAnalyst.trainAndUpdate();
                if (document.getElementById('muteSound').checked) closeSound.play();
            }

            updateTradeInfo() {
                if (activeTrade) {
                    const elapsed = Math.floor((Date.now() - activeTrade.startTime) / 1000);
                    const days = Math.floor(elapsed / (24 * 3600));
                    const hours = Math.floor((elapsed % (24 * 3600)) / 3600);
                    const minutes = Math.floor((elapsed % 3600) / 60);
                    const timeStr = `${days > 0 ? days + 'д ' : ''}${hours}ч ${minutes}м`;
                    document.getElementById('tradeInfo').textContent = `${activeTrade.type.toUpperCase()} | Вход: ${activeTrade.openPrice.toFixed(4)} | TP: ${activeTrade.takeProfit.toFixed(4)} | Время: ${timeStr}`;
                }
            }
        }

        class MarketAI {
            constructor() {
                this.model = this.createModel();
                this.isTrained = false;
            }

            createModel() {
                const model = tf.sequential();
                model.add(tf.layers.lstm({ units: 50, inputShape: [20, 3], returnSequences: true }));
                model.add(tf.layers.lstm({ units: 50 }));
                model.add(tf.layers.dense({ units: 2, activation: 'softmax' })); // 2 выхода: лонг/шорт
                model.compile({ optimizer: 'adam', loss: 'categoricalCrossentropy' });
                return model;
            }

            async trainModel() {
                if (closePrices.length < 40 || tradeHistory.length < 10) return;

                const lookback = 20;
                const xs = [];
                const ys = [];
                const { nwe: nweWide } = calculateNWE(closePrices, mult);
                const { nwe: nweNarrow, sae: saeNarrow } = calculateNWE(closePrices, mult2);
                const ema100 = calculateEMA(closePrices, 100);

                for (let i = lookback; i < closePrices.length - 1; i++) {
                    const input = [];
                    for (let j = i - lookback; j < i; j++) {
                        input.push([
                            closePrices[j],
                            nweWide[j] - closePrices[j], // Отклонение от широкого канала
                            ema100[j] - closePrices[j]   // Отклонение от EMA
                        ]);
                    }
                    const profit = tradeHistory.find(t => Math.abs(new Date(t.openTime) - new Date(candles[i].x)) < 15*60*1000)?.profit || 0;
                    xs.push(input);
                    ys.push(profit > 0 && tradeHistory.some(t => t.type === 'long' && Math.abs(new Date(t.openTime) - new Date(candles[i].x)) < 15*60*1000) ? [1, 0] : [0, 1]);
                }

                if (xs.length < 5) return;

                const xsTensor = tf.tensor3d(xs);
                const ysTensor = tf.tensor2d(ys);

                await this.model.fit(xsTensor, ysTensor, {
                    epochs: 100,
                    batchSize: 32,
                    callbacks: {
                        onEpochEnd: (epoch, log) => console.log(`Epoch ${epoch}: loss = ${log.loss}`)
                    }
                });

                this.isTrained = true;
                tf.dispose([xsTensor, ysTensor]);
            }

            async predictEntryExit() {
                if (!this.isTrained || closePrices.length < 20) return null;

                const lookback = 20;
                const { nwe: nweWide } = calculateNWE(closePrices, mult);
                const { nwe: nweNarrow, sae: saeNarrow } = calculateNWE(closePrices, mult2);
                const ema100 = calculateEMA(closePrices, 100);
                const input = [];
                for (let i = closePrices.length - lookback; i < closePrices.length; i++) {
                    input.push([
                        closePrices[i],
                        nweWide[i] - closePrices[i],
                        ema100[i] - closePrices[i]
                    ]);
                }

                const inputTensor = tf.tensor3d([input]);
                const prediction = this.model.predict(inputTensor);
                const result = await prediction.data();
                tf.dispose([inputTensor, prediction]);

                const longProb = result[0];
                const shortProb = result[1];
                const lastPrice = closePrices[closePrices.length - 1];
                const middle = nweNarrow[nweNarrow.length - 1];
                const upperNarrow = middle + saeNarrow;
                const lowerNarrow = middle - saeNarrow;
                const ema100Last = ema100[ema100.length - 1];
                const ema200Last = calculateEMA(closePrices, 200)[closePrices.length - 1];

                // Строгая проверка сигнала
                if (longProb > 0.7 && ema100Last > ema200Last && lastPrice < middle) {
                    return {
                        entry: { type: 'long', price: lowerNarrow, time: new Date() },
                        exit: { type: 'long', price: upperNarrow, time: new Date() }
                    };
                } else if (shortProb > 0.7 && ema100Last < ema200Last && lastPrice > middle) {
                    return {
                        entry: { type: 'short', price: upperNarrow, time: new Date() },
                        exit: { type: 'short', price: lowerNarrow, time: new Date() }
                    };
                }
                return null;
            }

            async analyzeMarket() {
                const analysis = [];
                const displayCandles = candles.slice(-maxCandles);
                if (displayCandles.length === 0) return "Данные еще не загружены, анализ невозможен.";

                const lastPrice = closePrices[closePrices.length - 1];
                const { nwe } = calculateNWE(closePrices, mult);
                const { sae: sae2 } = calculateNWE(closePrices, mult2);
                const ema100 = calculateEMA(closePrices, 100);
                const ema200 = calculateEMA(closePrices, 200);
                const middle = nwe[nwe.length - 1];
                const upperWide = middle + calculateNWE(closePrices, mult).sae;
                const lowerWide = middle - calculateNWE(closePrices, mult).sae;
                const upperNarrow = middle + sae2;
                const lowerNarrow = middle - sae2;

                analysis.push("Текущий таймфрейм — 15 минут. Это короткий период, который позволяет ловить быстрые движения, но требует осторожности из-за рыночного шума.");
                analysis.push(`Цена сейчас около ${lastPrice}. Она находится между широким каналом с границами около ${lowerWide} и ${upperWide}, и узким каналом с уровнями ${lowerNarrow} и ${upperNarrow}.`);
                
                if (lastPrice > middle) {
                    analysis.push("Цена выше средней линии, что намекает на бычьи настроения. Но если она близко к верхней границе, это может быть признаком перекупленности.");
                } else {
                    analysis.push("Цена ниже средней, возможно, рынок склоняется к медвежьему настроению. Близость к нижней границе узкого канала может быть зоной разворота.");
                }

                const ema100Last = ema100[ema100.length - 1];
                const ema200Last = ema200[ema200.length - 1];
                if (ema100Last > ema200Last) {
                    analysis.push("EMA 100 выше EMA 200 — это сигнал долгосрочного роста. Лонги могут быть в приоритете, но следите за откатами.");
                } else {
                    analysis.push("EMA 100 ниже EMA 200 — тренд скорее нисходящий. Шорты выглядят интереснее, но локальные развороты возможны.");
                }

                const signal = await this.predictEntryExit();
                if (signal) {
                    analysis.push(`Модель рекомендует ${signal.entry.type === 'long' ? 'лонг' : 'шорт'}. Точка входа около ${signal.entry.price}, выход около ${signal.exit.price}. Это основано на анализе цен, каналов и EMA.`);
                    aiEntryPoint = signal.entry;
                    aiExitPoint = signal.exit;
                } else {
                    analysis.push("Сейчас четкого сигнала нет. Модель ждет более уверенных условий для входа.");
                    aiEntryPoint = null;
                    aiExitPoint = null;
                }

                if (tradeHistory.length > 0) {
                    const profitableTrades = tradeHistory.filter(t => t.profit > 0).length;
                    analysis.push(`Из всех сделок (${tradeHistory.length}) прибыльных было ${profitableTrades}. Стратегия работает, но точность можно улучшить с помощью модели.`);
                }

                return analysis.join('<br>');
            }

            provideRecommendations() {
                const recommendations = [];
                recommendations.push("Добавьте фильтр объемов через WebSocket (@kline с volume) для подтверждения сигналов.");
                recommendations.push("Подключите API стакана (wss://stream.binance.com:9443/ws/ldousdt@depth) для анализа уровней ликвидности.");
                recommendations.push("Добавьте выбор таймфреймов (1h, 4h) для более широкого анализа.");
                recommendations.push("Прошу данные о настроениях (Crypto Fear & Greed Index) для учета эмоций рынка.");
                recommendations.push("Увеличьте входные данные модели: добавьте объемы, RSI. Увеличьте эпохи до 200.");
                return recommendations.join('<br>');
            }

            async trainAndUpdate() {
                await this.trainModel();
                const signal = await this.predictEntryExit();
                if (signal) {
                    aiEntryPoint = signal.entry;
                    aiExitPoint = signal.exit;
                    tradeAnnotations.push({
                        type: 'point',
                        xValue: aiEntryPoint.time,
                        yValue: aiEntryPoint.price,
                        backgroundColor: aiEntryPoint.type === 'long' ? '#00ff00' : '#ff0000',
                        borderColor: '#ffffff',
                        radius: 6,
                        label: { content: 'Вход (ИИ)', enabled: true, position: 'top' }
                    });
                    tradeAnnotations.push({
                        type: 'point',
                        xValue: aiExitPoint.time,
                        yValue: aiExitPoint.price,
                        backgroundColor: '#00c108',
                        borderColor: '#ffffff',
                        radius: 6,
                        label: { content: 'Выход (ИИ)', enabled: true, position: 'top' }
                    });
                }
                document.getElementById('aiAnalysis').innerHTML = await this.analyzeMarket();
                document.getElementById('aiRecommendations').innerHTML = this.provideRecommendations();
                updateChart();
            }
        }

        const aiTrader = new TradingAI();
        const aiAnalyst = new MarketAI();

        function updateStats() {
            const totalProfit = tradeHistory.reduce((sum, trade) => sum + trade.profit, 0);
            const openTrades = activeTrade ? 1 : 0;
            document.getElementById('stats').textContent = `Открыто: ${openTrades} | Сделок: ${tradeHistory.length} | Прибыль: ${totalProfit.toFixed(2)} USDT`;
        }

        function updateTradeLog() {
            const log = document.getElementById('tradeLog');
            const lastTrades = tradeHistory.slice(-30).reverse();
            log.innerHTML = `<h2>Сделки</h2>` + lastTrades.map(trade => {
                const openTime = new Date(trade.openTime).toLocaleTimeString();
                const closeTime = new Date(trade.closeTime).toLocaleTimeString();
                return `${trade.type.toUpperCase()} | Открытие: ${trade.openPrice.toFixed(4)} (${openTime}) | Закрытие: ${trade.closePrice.toFixed(4)} (${closeTime}) | Прибыль: ${trade.profit.toFixed(2)} USDT`;
            }).join('<br>');
            log.scrollTop = 0;
        }

        const wsKline = new WebSocket('wss://stream.binance.com:9443/ws/ldousdt@kline_15m');
        const wsTrade = new WebSocket('wss://stream.binance.com:9443/ws/ldousdt@aggTrade');

        wsKline.onopen = () => console.log("Kline WebSocket connection opened");
        wsTrade.onopen = () => console.log("Trade WebSocket connection opened");

        wsKline.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.k) {
                const timestamp = new Date(data.k.t);
                const open = parseFloat(data.k.o);
                const high = parseFloat(data.k.h);
                const low = parseFloat(data.k.l);
                const close = parseFloat(data.k.c);

                if (Tx.length > 0 && candles[candles.length - 1].x.getTime() === timestamp.getTime()) {
                    candles[candles.length - 1] = { x: timestamp, o: open, h: high, l: low, c: close };
                    closePrices[closePrices.length - 1] = close;
                } else {
                    candles.push({ x: timestamp, o: open, h: high, l: low, c: close });
                    closePrices.push(close);
                }

                if (candles.length > maxCalcCandles) {
                    candles.shift();
                    closePrices.shift();
                }
                updateChart();
                aiAnalyst.trainAndUpdate();
            }
        };

        wsTrade.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.p) {
                lastPrice = parseFloat(data.p);
                lastPriceTime = new Date(data.T);
                updateChart();
                aiAnalyst.trainAndUpdate();
            }
        };

        wsKline.onerror = (error) => console.error("Kline WebSocket error:", error);
        wsTrade.onerror = (error) => console.error("Trade WebSocket error:", error);
        wsKline.onclose = () => console.log("Kline WebSocket connection closed");
        wsTrade.onclose = () => console.log("Trade WebSocket connection closed");

        function updateChart() {
            const displayCandles = candles.slice(-maxCandles);
            const displayClosePrices = closePrices.slice(-maxCandles);

            if (displayCandles.length === 0) return;

            const upperWicks = [];
            const lowerWicks = [];
            displayCandles.forEach(c => {
                const wickColor = c.o <= c.c ? '#ff9800' : '#90bff9';
                if (c.h > Math.max(c.o, c.c)) {
                    upperWicks.push({ x: c.x, y: c.h });
                    upperWicks.push({ x: c.x, y: Math.max(c.o, c.c) });
                    upperWicks.push({ x: c.x, y: null });
                }
                if (c.l < Math.min(c.o, c.c)) {
                    lowerWicks.push({ x: c.x, y: Math.min(c.o, c.c) });
                    lowerWicks.push({ x: c.x, y: c.l });
                    lowerWicks.push({ x: c.x, y: null });
                }
            });

            const { nwe, sae } = calculateNWE(closePrices, mult);
            const { sae: sae2 } = calculateNWE(closePrices, mult2);
            const displayNwe = nwe.slice(-maxCandles);
            const upper = displayNwe.map((v, i) => ({ x: displayCandles[i]?.x, y: v + sae }));
            const lower = displayNwe.map((v, i) => ({ x: displayCandles[i]?.x, y: v - sae }));
            const middle = displayNwe.map((v, i) => ({ x: displayCandles[i]?.x, y: v }));
            const upper2 = displayNwe.map((v, i) => ({ x: displayCandles[i]?.x, y: v + sae2 }));
            const lower2 = displayNwe.map((v, i) => ({ x: displayCandles[i]?.x, y: v - sae2 }));

            const ema100 = calculateEMA(closePrices, 100).slice(-maxCandles);
            const ema200 = calculateEMA(closePrices, 200).slice(-maxCandles);
            const ema100Data = ema100.map((v, i) => ({ x: displayCandles[i]?.x, y: v }));
            const ema200Data = ema200.map((v, i) => ({ x: displayCandles[i]?.x, y: v }));

            const annotations = displayCandles.map((c, i) => ({
                type: 'box',
                xMin: c.x.getTime() - 300000,
                xMax: c.x.getTime() + 300000,
                yMin: Math.min(c.o, c.c),
                yMax: Math.max(c.o, c.c),
                backgroundColor: 'rgba(0, 0, 0, 0)',
                borderColor: c.o <= c.c ? '#ff9800' : '#90bff9',
                borderWidth: 1
            })).concat(tradeAnnotations);

            const lastCandleTime = displayCandles[displayCandles.length - 1].x.getTime();
            const offsetTime = lastCandleTime + 900000;

            const lastPriceData = lastPrice && lastPriceTime ? [
                { x: displayCandles[0].x, y: lastPrice },
                { x: new Date(lastCandleTime), y: lastPrice }
            ] : [];

            chart.data.datasets[0].borderColor = displayCandles[displayCandles.length - 1].o <= displayCandles[displayCandles.length - 1].c ? '#ff9800' : '#90bff9';
            chart.data.datasets[1].borderColor = displayCandles[displayCandles.length - 1].o <= displayCandles[displayCandles.length - 1].c ? '#ff9800' : '#90bff9';

            if (lastPrice && lastPriceTime) {
                document.getElementById('currentPrice').textContent = `Текущая цена: ${lastPrice.toFixed(4)}`;
                const lastLowerWide = lower[lower.length - 1]?.y || 0;
                const lastUpperWide = upper[upper.length - 1]?.y || 0;
                const lastLowerNarrow = lower2[lower2.length - 1]?.y || 0;
                const lastUpperNarrow = upper2[upper2.length - 1]?.y || 0;
                aiTrader.checkTradeConditions(lastPrice, lastPriceTime, lastLowerWide, lastUpperWide, lastLowerNarrow, lastUpperNarrow);
            }

            chart.options.scales.x.min = displayCandles[0].x.getTime();
            chart.options.scales.x.max = offsetTime;

            chart.options.plugins.annotation.annotations = annotations;
            chart.data.datasets[0].data = upperWicks;
            chart.data.datasets[1].data = lowerWicks;
            chart.data.datasets[2].data = upper;
            chart.data.datasets[3].data = lower;
            chart.data.datasets[4].data = middle;
            chart.data.datasets[5].data = upper2;
            chart.data.datasets[6].data = lower2;
            chart.data.datasets[7].data = ema100Data;
            chart.data.datasets[8].data = ema200Data;
            chart.data.datasets[9].data = lastPriceData;
            chart.update();
        }

        async function fetchInitialCandles() {
            try {
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=LDOUSDT&interval=15m&limit=${maxCalcCandles}`);
                const data = await response.json();
                data.forEach(candle => {
                    const timestamp = new Date(parseInt(candle[0]));
                    const open = parseFloat(candle[1]);
                    const high = parseFloat(candle[2]);
                    const low = parseFloat(candle[3]);
                    const close = parseFloat(candle[4]);
                    candles.push({ x: timestamp, o: open, h: high, l: low, c: close });
                    closePrices.push(close);
                });
                if (candles.length > maxCalcCandles) {
                    candles.splice(0, candles.length - maxCalcCandles);
                    closePrices.splice(0, closePrices.length - maxCalcCandles);
                }
                updateChart();
                aiAnalyst.trainAndUpdate();
            } catch (error) {
                console.error("Error fetching initial candles:", error);
            }
        }

        fetchInitialCandles();
    </script>
</body>
</html>
