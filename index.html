<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LDO/USDT 15m - Nadaraya-Watson Envelope</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <style>
        body { background-color: #1e222d; color: white; font-family: Arial, sans-serif; margin: 0; padding: 20px; }
        canvas { max-width: 100%; }
    </style>
</head>
<body>
    <h1>LDO/USDT 15m - Nadaraya-Watson Envelope</h1>
    <canvas id="priceChart"></canvas>

    <script>
        console.log("Starting script...");

        const h = 8;
        const mult = 2.89; // Скорректировано для совпадения с TradingView (верх 0.8816, низ 0.8561)
        const repaint = true;
        const maxCandles = 126; // Отображаем 126 свечей
        const maxCalcCandles = 500; // Для расчета используем до 500 свечей

        const ctx = document.getElementById('priceChart').getContext('2d');
        console.log("Canvas context initialized:", ctx);

        const chart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [
                    {
                        label: 'Upper Wick',
                        data: [],
                        borderColor: '#ffffff',
                        borderWidth: 1,
                        pointRadius: 0,
                        fill: false
                    },
                    {
                        label: 'Lower Wick',
                        data: [],
                        borderColor: '#ffffff',
                        borderWidth: 1,
                        pointRadius: 0,
                        fill: false
                    },
                    {
                        label: 'Upper Envelope',
                        data: [],
                        borderColor: '#00c4b4',
                        borderWidth: 1,
                        pointRadius: 0,
                        fill: false
                    },
                    {
                        label: 'Lower Envelope',
                        data: [],
                        borderColor: '#ff1744',
                        borderWidth: 1,
                        pointRadius: 0,
                        fill: false
                    },
                    {
                        label: 'EMA 100',
                        data: [],
                        borderColor: '#d873f6',
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false
                    },
                    {
                        label: 'EMA 200',
                        data: [],
                        borderColor: '#ffffff',
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: false
                    }
                ]
            },
            options: {
                responsive: true,
                plugins: {
                    annotation: {
                        annotations: []
                    }
                },
                scales: {
                    x: {
                        type: 'time',
                        time: { unit: 'minute', displayFormats: { minute: 'HH:mm' } },
                        title: { display: true, text: 'Time' }
                    },
                    y: { title: { display: true, text: 'Price (USDT)' } }
                }
            }
        });
        console.log("Chart initialized:", chart);

        function gauss(x, h) {
            return Math.exp(-(Math.pow(x, 2) / (h * h * 2)));
        }

        function calculateNWE(prices) {
            const nwe = [];
            let sae = 0;
            const n = prices.length;

            for (let i = 0; i < n; i++) {
                let sum = 0, sumw = 0;
                for (let j = 0; j < n; j++) {
                    const w = gauss(i - j, h);
                    sum += prices[j] * w;
                    sumw += w;
                }
                const y = sum / sumw;
                sae += Math.abs(prices[i] - y);
                nwe.push(y);
            }

            sae = (sae / Math.min(499, n - 1)) * mult;
            return { nwe, sae };
        }

        function calculateEMA(prices, period) {
            const k = 2 / (period + 1);
            const ema = [];
            let previousEMA = prices[0];

            for (let i = 0; i < prices.length; i++) {
                const value = prices[i] * k + previousEMA * (1 - k);
                ema.push(value);
                previousEMA = value;
            }

            return ema;
        }

        const candles = [];
        const closePrices = [];
        const ws = new WebSocket('wss://stream.binance.com:9443/ws/ldousdt@kline_15m');

        ws.onopen = () => {
            console.log("WebSocket connection opened");
        };

        ws.onmessage = (event) => {
            console.log("WebSocket message received:", event.data);
            const data = JSON.parse(event.data);
            if (data.k) {
                const timestamp = new Date(data.k.t);
                const open = parseFloat(data.k.o);
                const high = parseFloat(data.k.h);
                const low = parseFloat(data.k.l);
                const close = parseFloat(data.k.c);

                if (candles.length > 0 && candles[candles.length - 1].x.getTime() === timestamp.getTime()) {
                    candles[candles.length - 1] = { x: timestamp, o: open, h: high, l: low, c: close };
                    closePrices[closePrices.length - 1] = close;
                } else {
                    candles.push({ x: timestamp, o: open, h: high, l: low, c: close });
                    closePrices.push(close);
                }

                if (candles.length > maxCalcCandles) {
                    candles.shift();
                    closePrices.shift();
                }

                console.log("Candles updated:", candles.length);

                // Ограничиваем отображение последними 126 свечами
                const displayCandles = candles.slice(-maxCandles);
                const displayClosePrices = closePrices.slice(-maxCandles);

                const upperWicks = [];
                const lowerWicks = [];
                displayCandles.forEach(c => {
                    if (c.h > Math.max(c.o, c.c)) {
                        upperWicks.push({ x: c.x, y: c.h });
                        upperWicks.push({ x: c.x, y: Math.max(c.o, c.c) });
                        upperWicks.push({ x: c.x, y: null });
                    }

                    if (c.l < Math.min(c.o, c.c)) {
                        lowerWicks.push({ x: c.x, y: Math.min(c.o, c.c) });
                        lowerWicks.push({ x: c.x, y: c.l });
                        lowerWicks.push({ x: c.x, y: null });
                    }
                });

                // Перерасчет NWE на основе всех свечей (до 500)
                const { nwe, sae } = calculateNWE(closePrices);
                // Ограничиваем отображение NWE последними 126 свечами
                const displayNwe = nwe.slice(-maxCandles);
                const upper = displayNwe.map((v, i) => ({ x: displayCandles[i]?.x, y: v + sae }));
                const lower = displayNwe.map((v, i) => ({ x: displayCandles[i]?.x, y: v - sae }));

                const ema100 = calculateEMA(displayClosePrices, 100);
                const ema200 = calculateEMA(displayClosePrices, 200);
                const ema100Data = ema100.map((v, i) => ({ x: displayCandles[i]?.x, y: v }));
                const ema200Data = ema200.map((v, i) => ({ x: displayCandles[i]?.x, y: v }));

                const annotations = displayCandles.map((c, i) => ({
                    type: 'box',
                    xMin: c.x.getTime() - 300000,
                    xMax: c.x.getTime() + 300000,
                    yMin: Math.min(c.o, c.c),
                    yMax: Math.max(c.o, c.c),
                    backgroundColor: c.o <= c.c ? '#00c4b4' : '#ff1744',
                    borderColor: '#ffffff',
                    borderWidth: 1
                }));

                chart.options.plugins.annotation.annotations = annotations;
                chart.data.datasets[0].data = upperWicks;
                chart.data.datasets[1].data = lowerWicks;
                chart.data.datasets[2].data = upper;
                chart.data.datasets[3].data = lower;
                chart.data.datasets[4].data = ema100Data;
                chart.data.datasets[5].data = ema200Data;
                chart.update();
                console.log("Chart updated");
            }
        };

        ws.onerror = (error) => {
            console.error("WebSocket error:", error);
        };

        ws.onclose = () => {
            console.log("WebSocket connection closed");
        };

        async function fetchInitialCandles() {
            try {
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=LDOUSDT&interval=15m&limit=${maxCalcCandles}`);
                const data = await response.json();
                console.log("Fetched initial data:", data);

                data.forEach(candle => {
                    const timestamp = new Date(parseInt(candle[0]));
                    const open = parseFloat(candle[1]);
                    const high = parseFloat(candle[2]);
                    const low = parseFloat(candle[3]);
                    const close = parseFloat(candle[4]);

                    candles.push({ x: timestamp, o: open, h: high, l: low, c: close });
                    closePrices.push(close);
                });

                if (candles.length > maxCalcCandles) {
                    candles.splice(0, candles.length - maxCalcCandles);
                    closePrices.splice(0, closePrices.length - maxCalcCandles);
                }

                console.log("Initial candles processed:", candles.length);

                const displayCandles = candles.slice(-maxCandles);
                const displayClosePrices = closePrices.slice(-maxCandles);

                const upperWicks = [];
                const lowerWicks = [];
                displayCandles.forEach(c => {
                    if (c.h > Math.max(c.o, c.c)) {
                        upperWicks.push({ x: c.x, y: c.h });
                        upperWicks.push({ x: c.x, y: Math.max(c.o, c.c) });
                        upperWicks.push({ x: c.x, y: null });
                    }

                    if (c.l < Math.min(c.o, c.c)) {
                        lowerWicks.push({ x: c.x, y: Math.min(c.o, c.c) });
                        lowerWicks.push({ x: c.x, y: c.l });
                        lowerWicks.push({ x: c.x, y: null });
                    }
                });

                const { nwe, sae } = calculateNWE(closePrices);
                const displayNwe = nwe.slice(-maxCandles);
                const upper = displayNwe.map((v, i) => ({ x: displayCandles[i]?.x, y: v + sae }));
                const lower = displayNwe.map((v, i) => ({ x: displayCandles[i]?.x, y: v - sae }));

                const ema100 = calculateEMA(displayClosePrices, 100);
                const ema200 = calculateEMA(displayClosePrices, 200);
                const ema100Data = ema100.map((v, i) => ({ x: displayCandles[i]?.x, y: v }));
                const ema200Data = ema200.map((v, i) => ({ x: displayCandles[i]?.x, y: v }));

                const annotations = displayCandles.map((c, i) => ({
                    type: 'box',
                    xMin: c.x.getTime() - 300000,
                    xMax: c.x.getTime() + 300000,
                    yMin: Math.min(c.o, c.c),
                    yMax: Math.max(c.o, c.c),
                    backgroundColor: c.o <= c.c ? '#00c4b4' : '#ff1744',
                    borderColor: '#ffffff',
                    borderWidth: 1
                }));

                chart.options.plugins.annotation.annotations = annotations;
                chart.data.datasets[0].data = upperWicks;
                chart.data.datasets[1].data = lowerWicks;
                chart.data.datasets[2].data = upper;
                chart.data.datasets[3].data = lower;
                chart.data.datasets[4].data = ema100Data;
                chart.data.datasets[5].data = ema200Data;
                chart.update();
                console.log("Initial chart updated");
            } catch (error) {
                console.error("Error fetching initial candles:", error);
            }
        }

        fetchInitialCandles();
    </script>
</body>
</html>
